// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.

#![cfg_attr(rustfmt, rustfmt_skip)]

use rowan::TransparentNewType;

use crate::{
    SyntaxNode, SyntaxKind::*,
    syntax_node::{RaTypes, TreeArc},
    ast::{self, AstNode},
};

// Alias
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Alias {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Alias {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Alias {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ALIAS => Some(Alias::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Alias {
    type Owned = TreeArc<Alias>;
    fn to_owned(&self) -> TreeArc<Alias> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for Alias {}
impl Alias {}

// ArgList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ArgList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ArgList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ARG_LIST => Some(ArgList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ArgList {
    type Owned = TreeArc<ArgList>;
    fn to_owned(&self) -> TreeArc<ArgList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = &Expr> {
        super::children(self)
    }
}

// ArrayExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ArrayExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ArrayExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ARRAY_EXPR => Some(ArrayExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ArrayExpr {
    type Owned = TreeArc<ArrayExpr>;
    fn to_owned(&self) -> TreeArc<ArrayExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ArrayExpr {
    pub fn exprs(&self) -> impl Iterator<Item = &Expr> {
        super::children(self)
    }
}

// ArrayType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ArrayType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ArrayType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ARRAY_TYPE => Some(ArrayType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ArrayType {
    type Owned = TreeArc<ArrayType>;
    fn to_owned(&self) -> TreeArc<ArrayType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ArrayType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// AssocTypeArg
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct AssocTypeArg {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for AssocTypeArg {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for AssocTypeArg {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ASSOC_TYPE_ARG => Some(AssocTypeArg::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for AssocTypeArg {
    type Owned = TreeArc<AssocTypeArg>;
    fn to_owned(&self) -> TreeArc<AssocTypeArg> { TreeArc::cast(self.syntax.to_owned()) }
}


impl AssocTypeArg {
    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }

    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// Attr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Attr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Attr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ATTR => Some(Attr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Attr {
    type Owned = TreeArc<Attr>;
    fn to_owned(&self) -> TreeArc<Attr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Attr {
    pub fn value(&self) -> Option<&TokenTree> {
        super::child_opt(self)
    }
}

// BinExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for BinExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for BinExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BIN_EXPR => Some(BinExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for BinExpr {
    type Owned = TreeArc<BinExpr>;
    fn to_owned(&self) -> TreeArc<BinExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl BinExpr {}

// BindPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct BindPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for BindPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for BindPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BIND_PAT => Some(BindPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for BindPat {
    type Owned = TreeArc<BindPat>;
    fn to_owned(&self) -> TreeArc<BindPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for BindPat {}
impl BindPat {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }
}

// Block
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Block {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Block {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BLOCK => Some(Block::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Block {
    type Owned = TreeArc<Block>;
    fn to_owned(&self) -> TreeArc<Block> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AttrsOwner for Block {}
impl Block {
    pub fn statements(&self) -> impl Iterator<Item = &Stmt> {
        super::children(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// BlockExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for BlockExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for BlockExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BLOCK_EXPR => Some(BlockExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for BlockExpr {
    type Owned = TreeArc<BlockExpr>;
    fn to_owned(&self) -> TreeArc<BlockExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl BlockExpr {
    pub fn block(&self) -> Option<&Block> {
        super::child_opt(self)
    }
}

// BreakExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for BreakExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for BreakExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BREAK_EXPR => Some(BreakExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for BreakExpr {
    type Owned = TreeArc<BreakExpr>;
    fn to_owned(&self) -> TreeArc<BreakExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl BreakExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// Byte
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Byte {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Byte {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Byte {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BYTE => Some(Byte::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Byte {
    type Owned = TreeArc<Byte>;
    fn to_owned(&self) -> TreeArc<Byte> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for Byte {}
impl Byte {}

// ByteString
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ByteString {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ByteString {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ByteString {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            BYTE_STRING => Some(ByteString::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ByteString {
    type Owned = TreeArc<ByteString>;
    fn to_owned(&self) -> TreeArc<ByteString> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for ByteString {}
impl ByteString {}

// CallExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for CallExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for CallExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CALL_EXPR => Some(CallExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for CallExpr {
    type Owned = TreeArc<CallExpr>;
    fn to_owned(&self) -> TreeArc<CallExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::ArgListOwner for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// CastExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for CastExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for CastExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CAST_EXPR => Some(CastExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for CastExpr {
    type Owned = TreeArc<CastExpr>;
    fn to_owned(&self) -> TreeArc<CastExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl CastExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }

    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// Char
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Char {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Char {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Char {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CHAR => Some(Char::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Char {
    type Owned = TreeArc<Char>;
    fn to_owned(&self) -> TreeArc<Char> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for Char {}
impl Char {}

// Comment
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Comment {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Comment {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Comment {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            COMMENT => Some(Comment::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Comment {
    type Owned = TreeArc<Comment>;
    fn to_owned(&self) -> TreeArc<Comment> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for Comment {}
impl Comment {}

// Condition
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Condition {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Condition {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CONDITION => Some(Condition::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Condition {
    type Owned = TreeArc<Condition>;
    fn to_owned(&self) -> TreeArc<Condition> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Condition {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// ConstDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ConstDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ConstDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ConstDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CONST_DEF => Some(ConstDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ConstDef {
    type Owned = TreeArc<ConstDef>;
    fn to_owned(&self) -> TreeArc<ConstDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for ConstDef {}
impl ast::NameOwner for ConstDef {}
impl ast::TypeParamsOwner for ConstDef {}
impl ast::AttrsOwner for ConstDef {}
impl ast::DocCommentsOwner for ConstDef {}
impl ast::TypeAscriptionOwner for ConstDef {}
impl ConstDef {}

// ContinueExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ContinueExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ContinueExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            CONTINUE_EXPR => Some(ContinueExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ContinueExpr {
    type Owned = TreeArc<ContinueExpr>;
    fn to_owned(&self) -> TreeArc<ContinueExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ContinueExpr {}

// DynTraitType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct DynTraitType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for DynTraitType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for DynTraitType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            DYN_TRAIT_TYPE => Some(DynTraitType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for DynTraitType {
    type Owned = TreeArc<DynTraitType>;
    fn to_owned(&self) -> TreeArc<DynTraitType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl DynTraitType {}

// EnumDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct EnumDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for EnumDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for EnumDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ENUM_DEF => Some(EnumDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for EnumDef {
    type Owned = TreeArc<EnumDef>;
    fn to_owned(&self) -> TreeArc<EnumDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for EnumDef {}
impl ast::NameOwner for EnumDef {}
impl ast::TypeParamsOwner for EnumDef {}
impl ast::AttrsOwner for EnumDef {}
impl ast::DocCommentsOwner for EnumDef {}
impl EnumDef {
    pub fn variant_list(&self) -> Option<&EnumVariantList> {
        super::child_opt(self)
    }
}

// EnumVariant
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for EnumVariant {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for EnumVariant {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ENUM_VARIANT => Some(EnumVariant::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for EnumVariant {
    type Owned = TreeArc<EnumVariant>;
    fn to_owned(&self) -> TreeArc<EnumVariant> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for EnumVariant {}
impl ast::DocCommentsOwner for EnumVariant {}
impl ast::AttrsOwner for EnumVariant {}
impl EnumVariant {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// EnumVariantList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for EnumVariantList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for EnumVariantList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ENUM_VARIANT_LIST => Some(EnumVariantList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for EnumVariantList {
    type Owned = TreeArc<EnumVariantList>;
    fn to_owned(&self) -> TreeArc<EnumVariantList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl EnumVariantList {
    pub fn variants(&self) -> impl Iterator<Item = &EnumVariant> {
        super::children(self)
    }
}

// Expr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Expr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Expr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ExprKind<'a> {
    TupleExpr(&'a TupleExpr),
    ArrayExpr(&'a ArrayExpr),
    ParenExpr(&'a ParenExpr),
    PathExpr(&'a PathExpr),
    LambdaExpr(&'a LambdaExpr),
    IfExpr(&'a IfExpr),
    LoopExpr(&'a LoopExpr),
    ForExpr(&'a ForExpr),
    WhileExpr(&'a WhileExpr),
    ContinueExpr(&'a ContinueExpr),
    BreakExpr(&'a BreakExpr),
    Label(&'a Label),
    BlockExpr(&'a BlockExpr),
    ReturnExpr(&'a ReturnExpr),
    MatchExpr(&'a MatchExpr),
    StructLit(&'a StructLit),
    CallExpr(&'a CallExpr),
    IndexExpr(&'a IndexExpr),
    MethodCallExpr(&'a MethodCallExpr),
    FieldExpr(&'a FieldExpr),
    TryExpr(&'a TryExpr),
    CastExpr(&'a CastExpr),
    RefExpr(&'a RefExpr),
    PrefixExpr(&'a PrefixExpr),
    RangeExpr(&'a RangeExpr),
    BinExpr(&'a BinExpr),
    Literal(&'a Literal),
}
impl<'a> From<&'a TupleExpr> for &'a Expr {
    fn from(n: &'a TupleExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ArrayExpr> for &'a Expr {
    fn from(n: &'a ArrayExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ParenExpr> for &'a Expr {
    fn from(n: &'a ParenExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PathExpr> for &'a Expr {
    fn from(n: &'a PathExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a LambdaExpr> for &'a Expr {
    fn from(n: &'a LambdaExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a IfExpr> for &'a Expr {
    fn from(n: &'a IfExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a LoopExpr> for &'a Expr {
    fn from(n: &'a LoopExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ForExpr> for &'a Expr {
    fn from(n: &'a ForExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a WhileExpr> for &'a Expr {
    fn from(n: &'a WhileExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ContinueExpr> for &'a Expr {
    fn from(n: &'a ContinueExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a BreakExpr> for &'a Expr {
    fn from(n: &'a BreakExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a Label> for &'a Expr {
    fn from(n: &'a Label) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a BlockExpr> for &'a Expr {
    fn from(n: &'a BlockExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ReturnExpr> for &'a Expr {
    fn from(n: &'a ReturnExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a MatchExpr> for &'a Expr {
    fn from(n: &'a MatchExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a StructLit> for &'a Expr {
    fn from(n: &'a StructLit) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a CallExpr> for &'a Expr {
    fn from(n: &'a CallExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a IndexExpr> for &'a Expr {
    fn from(n: &'a IndexExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a MethodCallExpr> for &'a Expr {
    fn from(n: &'a MethodCallExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a FieldExpr> for &'a Expr {
    fn from(n: &'a FieldExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TryExpr> for &'a Expr {
    fn from(n: &'a TryExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a CastExpr> for &'a Expr {
    fn from(n: &'a CastExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a RefExpr> for &'a Expr {
    fn from(n: &'a RefExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PrefixExpr> for &'a Expr {
    fn from(n: &'a PrefixExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a RangeExpr> for &'a Expr {
    fn from(n: &'a RangeExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a BinExpr> for &'a Expr {
    fn from(n: &'a BinExpr) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a Literal> for &'a Expr {
    fn from(n: &'a Literal) -> &'a Expr {
        Expr::cast(&n.syntax).unwrap()
    }
}


impl AstNode for Expr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | TUPLE_EXPR
            | ARRAY_EXPR
            | PAREN_EXPR
            | PATH_EXPR
            | LAMBDA_EXPR
            | IF_EXPR
            | LOOP_EXPR
            | FOR_EXPR
            | WHILE_EXPR
            | CONTINUE_EXPR
            | BREAK_EXPR
            | LABEL
            | BLOCK_EXPR
            | RETURN_EXPR
            | MATCH_EXPR
            | STRUCT_LIT
            | CALL_EXPR
            | INDEX_EXPR
            | METHOD_CALL_EXPR
            | FIELD_EXPR
            | TRY_EXPR
            | CAST_EXPR
            | REF_EXPR
            | PREFIX_EXPR
            | RANGE_EXPR
            | BIN_EXPR
            | LITERAL => Some(Expr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Expr {
    type Owned = TreeArc<Expr>;
    fn to_owned(&self) -> TreeArc<Expr> { TreeArc::cast(self.syntax.to_owned()) }
}

impl Expr {
    pub fn kind(&self) -> ExprKind {
        match self.syntax.kind() {
            TUPLE_EXPR => ExprKind::TupleExpr(TupleExpr::cast(&self.syntax).unwrap()),
            ARRAY_EXPR => ExprKind::ArrayExpr(ArrayExpr::cast(&self.syntax).unwrap()),
            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr::cast(&self.syntax).unwrap()),
            PATH_EXPR => ExprKind::PathExpr(PathExpr::cast(&self.syntax).unwrap()),
            LAMBDA_EXPR => ExprKind::LambdaExpr(LambdaExpr::cast(&self.syntax).unwrap()),
            IF_EXPR => ExprKind::IfExpr(IfExpr::cast(&self.syntax).unwrap()),
            LOOP_EXPR => ExprKind::LoopExpr(LoopExpr::cast(&self.syntax).unwrap()),
            FOR_EXPR => ExprKind::ForExpr(ForExpr::cast(&self.syntax).unwrap()),
            WHILE_EXPR => ExprKind::WhileExpr(WhileExpr::cast(&self.syntax).unwrap()),
            CONTINUE_EXPR => ExprKind::ContinueExpr(ContinueExpr::cast(&self.syntax).unwrap()),
            BREAK_EXPR => ExprKind::BreakExpr(BreakExpr::cast(&self.syntax).unwrap()),
            LABEL => ExprKind::Label(Label::cast(&self.syntax).unwrap()),
            BLOCK_EXPR => ExprKind::BlockExpr(BlockExpr::cast(&self.syntax).unwrap()),
            RETURN_EXPR => ExprKind::ReturnExpr(ReturnExpr::cast(&self.syntax).unwrap()),
            MATCH_EXPR => ExprKind::MatchExpr(MatchExpr::cast(&self.syntax).unwrap()),
            STRUCT_LIT => ExprKind::StructLit(StructLit::cast(&self.syntax).unwrap()),
            CALL_EXPR => ExprKind::CallExpr(CallExpr::cast(&self.syntax).unwrap()),
            INDEX_EXPR => ExprKind::IndexExpr(IndexExpr::cast(&self.syntax).unwrap()),
            METHOD_CALL_EXPR => ExprKind::MethodCallExpr(MethodCallExpr::cast(&self.syntax).unwrap()),
            FIELD_EXPR => ExprKind::FieldExpr(FieldExpr::cast(&self.syntax).unwrap()),
            TRY_EXPR => ExprKind::TryExpr(TryExpr::cast(&self.syntax).unwrap()),
            CAST_EXPR => ExprKind::CastExpr(CastExpr::cast(&self.syntax).unwrap()),
            REF_EXPR => ExprKind::RefExpr(RefExpr::cast(&self.syntax).unwrap()),
            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr::cast(&self.syntax).unwrap()),
            RANGE_EXPR => ExprKind::RangeExpr(RangeExpr::cast(&self.syntax).unwrap()),
            BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(&self.syntax).unwrap()),
            LITERAL => ExprKind::Literal(Literal::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Expr {}

// ExprStmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ExprStmt {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ExprStmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            EXPR_STMT => Some(ExprStmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ExprStmt {
    type Owned = TreeArc<ExprStmt>;
    fn to_owned(&self) -> TreeArc<ExprStmt> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// ExternCrateItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ExternCrateItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ExternCrateItem {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ExternCrateItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            EXTERN_CRATE_ITEM => Some(ExternCrateItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ExternCrateItem {
    type Owned = TreeArc<ExternCrateItem>;
    fn to_owned(&self) -> TreeArc<ExternCrateItem> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ExternCrateItem {
    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }

    pub fn alias(&self) -> Option<&Alias> {
        super::child_opt(self)
    }
}

// FalseKw
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FalseKw {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FalseKw {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FalseKw {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FALSE_KW => Some(FalseKw::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FalseKw {
    type Owned = TreeArc<FalseKw>;
    fn to_owned(&self) -> TreeArc<FalseKw> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for FalseKw {}
impl FalseKw {}

// FieldExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FieldExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FieldExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FIELD_EXPR => Some(FieldExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FieldExpr {
    type Owned = TreeArc<FieldExpr>;
    fn to_owned(&self) -> TreeArc<FieldExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl FieldExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }

    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }
}

// FieldPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FieldPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FieldPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FieldPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FIELD_PAT => Some(FieldPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FieldPat {
    type Owned = TreeArc<FieldPat>;
    fn to_owned(&self) -> TreeArc<FieldPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for FieldPat {}
impl FieldPat {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }
}

// FieldPatList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FieldPatList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FieldPatList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FieldPatList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FIELD_PAT_LIST => Some(FieldPatList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FieldPatList {
    type Owned = TreeArc<FieldPatList>;
    fn to_owned(&self) -> TreeArc<FieldPatList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl FieldPatList {
    pub fn field_pats(&self) -> impl Iterator<Item = &FieldPat> {
        super::children(self)
    }

    pub fn bind_pats(&self) -> impl Iterator<Item = &BindPat> {
        super::children(self)
    }
}

// FloatNumber
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FloatNumber {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FloatNumber {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FloatNumber {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FLOAT_NUMBER => Some(FloatNumber::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FloatNumber {
    type Owned = TreeArc<FloatNumber>;
    fn to_owned(&self) -> TreeArc<FloatNumber> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for FloatNumber {}
impl FloatNumber {}

// FnDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FnDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FnDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FnDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FN_DEF => Some(FnDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FnDef {
    type Owned = TreeArc<FnDef>;
    fn to_owned(&self) -> TreeArc<FnDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for FnDef {}
impl ast::NameOwner for FnDef {}
impl ast::TypeParamsOwner for FnDef {}
impl ast::AttrsOwner for FnDef {}
impl ast::DocCommentsOwner for FnDef {}
impl FnDef {
    pub fn param_list(&self) -> Option<&ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<&Block> {
        super::child_opt(self)
    }

    pub fn ret_type(&self) -> Option<&RetType> {
        super::child_opt(self)
    }
}

// FnPointerType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct FnPointerType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for FnPointerType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for FnPointerType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FN_POINTER_TYPE => Some(FnPointerType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for FnPointerType {
    type Owned = TreeArc<FnPointerType>;
    fn to_owned(&self) -> TreeArc<FnPointerType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl FnPointerType {
    pub fn param_list(&self) -> Option<&ParamList> {
        super::child_opt(self)
    }

    pub fn ret_type(&self) -> Option<&RetType> {
        super::child_opt(self)
    }
}

// ForExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ForExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ForExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FOR_EXPR => Some(ForExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ForExpr {
    type Owned = TreeArc<ForExpr>;
    fn to_owned(&self) -> TreeArc<ForExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::LoopBodyOwner for ForExpr {}
impl ForExpr {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }

    pub fn iterable(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// ForType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ForType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ForType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ForType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            FOR_TYPE => Some(ForType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ForType {
    type Owned = TreeArc<ForType>;
    fn to_owned(&self) -> TreeArc<ForType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ForType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// IfExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for IfExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for IfExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            IF_EXPR => Some(IfExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for IfExpr {
    type Owned = TreeArc<IfExpr>;
    fn to_owned(&self) -> TreeArc<IfExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl IfExpr {
    pub fn condition(&self) -> Option<&Condition> {
        super::child_opt(self)
    }
}

// ImplBlock
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ImplBlock {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ImplBlock {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ImplBlock {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            IMPL_BLOCK => Some(ImplBlock::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ImplBlock {
    type Owned = TreeArc<ImplBlock>;
    fn to_owned(&self) -> TreeArc<ImplBlock> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::TypeParamsOwner for ImplBlock {}
impl ImplBlock {
    pub fn item_list(&self) -> Option<&ItemList> {
        super::child_opt(self)
    }
}

// ImplItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ImplItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ImplItem {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ImplItemKind<'a> {
    FnDef(&'a FnDef),
    TypeAliasDef(&'a TypeAliasDef),
    ConstDef(&'a ConstDef),
}
impl<'a> From<&'a FnDef> for &'a ImplItem {
    fn from(n: &'a FnDef) -> &'a ImplItem {
        ImplItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TypeAliasDef> for &'a ImplItem {
    fn from(n: &'a TypeAliasDef) -> &'a ImplItem {
        ImplItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ConstDef> for &'a ImplItem {
    fn from(n: &'a ConstDef) -> &'a ImplItem {
        ImplItem::cast(&n.syntax).unwrap()
    }
}


impl AstNode for ImplItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | FN_DEF
            | TYPE_ALIAS_DEF
            | CONST_DEF => Some(ImplItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ImplItem {
    type Owned = TreeArc<ImplItem>;
    fn to_owned(&self) -> TreeArc<ImplItem> { TreeArc::cast(self.syntax.to_owned()) }
}

impl ImplItem {
    pub fn kind(&self) -> ImplItemKind {
        match self.syntax.kind() {
            FN_DEF => ImplItemKind::FnDef(FnDef::cast(&self.syntax).unwrap()),
            TYPE_ALIAS_DEF => ImplItemKind::TypeAliasDef(TypeAliasDef::cast(&self.syntax).unwrap()),
            CONST_DEF => ImplItemKind::ConstDef(ConstDef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ImplItem {}

// ImplTraitType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ImplTraitType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ImplTraitType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ImplTraitType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            IMPL_TRAIT_TYPE => Some(ImplTraitType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ImplTraitType {
    type Owned = TreeArc<ImplTraitType>;
    fn to_owned(&self) -> TreeArc<ImplTraitType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ImplTraitType {}

// IndexExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for IndexExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for IndexExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            INDEX_EXPR => Some(IndexExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for IndexExpr {
    type Owned = TreeArc<IndexExpr>;
    fn to_owned(&self) -> TreeArc<IndexExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl IndexExpr {}

// IntNumber
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct IntNumber {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for IntNumber {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for IntNumber {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            INT_NUMBER => Some(IntNumber::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for IntNumber {
    type Owned = TreeArc<IntNumber>;
    fn to_owned(&self) -> TreeArc<IntNumber> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for IntNumber {}
impl IntNumber {}

// ItemList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ItemList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ItemList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ItemList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            ITEM_LIST => Some(ItemList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ItemList {
    type Owned = TreeArc<ItemList>;
    fn to_owned(&self) -> TreeArc<ItemList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::FnDefOwner for ItemList {}
impl ast::ModuleItemOwner for ItemList {}
impl ItemList {
    pub fn impl_items(&self) -> impl Iterator<Item = &ImplItem> {
        super::children(self)
    }
}

// Label
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Label {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Label {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Label {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LABEL => Some(Label::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Label {
    type Owned = TreeArc<Label>;
    fn to_owned(&self) -> TreeArc<Label> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Label {}

// LambdaExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LambdaExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LambdaExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LAMBDA_EXPR => Some(LambdaExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LambdaExpr {
    type Owned = TreeArc<LambdaExpr>;
    fn to_owned(&self) -> TreeArc<LambdaExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl LambdaExpr {
    pub fn param_list(&self) -> Option<&ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// LetStmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LetStmt {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LetStmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LET_STMT => Some(LetStmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LetStmt {
    type Owned = TreeArc<LetStmt>;
    fn to_owned(&self) -> TreeArc<LetStmt> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::TypeAscriptionOwner for LetStmt {}
impl LetStmt {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }

    pub fn initializer(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// Lifetime
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Lifetime {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Lifetime {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Lifetime {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LIFETIME => Some(Lifetime::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Lifetime {
    type Owned = TreeArc<Lifetime>;
    fn to_owned(&self) -> TreeArc<Lifetime> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for Lifetime {}
impl Lifetime {}

// LifetimeArg
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LifetimeArg {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LifetimeArg {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LifetimeArg {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LIFETIME_ARG => Some(LifetimeArg::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LifetimeArg {
    type Owned = TreeArc<LifetimeArg>;
    fn to_owned(&self) -> TreeArc<LifetimeArg> { TreeArc::cast(self.syntax.to_owned()) }
}


impl LifetimeArg {
    pub fn lifetime(&self) -> Option<&Lifetime> {
        super::child_opt(self)
    }
}

// LifetimeParam
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LifetimeParam {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LifetimeParam {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LifetimeParam {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LIFETIME_PARAM => Some(LifetimeParam::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LifetimeParam {
    type Owned = TreeArc<LifetimeParam>;
    fn to_owned(&self) -> TreeArc<LifetimeParam> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AttrsOwner for LifetimeParam {}
impl LifetimeParam {
    pub fn lifetime(&self) -> Option<&Lifetime> {
        super::child_opt(self)
    }
}

// Literal
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Literal {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Literal {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LITERAL => Some(Literal::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Literal {
    type Owned = TreeArc<Literal>;
    fn to_owned(&self) -> TreeArc<Literal> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Literal {
    pub fn literal_expr(&self) -> Option<&LiteralExpr> {
        super::child_opt(self)
    }
}

// LiteralExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LiteralExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LiteralExprKind<'a> {
    String(&'a String),
    ByteString(&'a ByteString),
    RawString(&'a RawString),
    RawByteString(&'a RawByteString),
    Char(&'a Char),
    Byte(&'a Byte),
    IntNumber(&'a IntNumber),
    FloatNumber(&'a FloatNumber),
    TrueKw(&'a TrueKw),
    FalseKw(&'a FalseKw),
}
impl<'a> From<&'a String> for &'a LiteralExpr {
    fn from(n: &'a String) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ByteString> for &'a LiteralExpr {
    fn from(n: &'a ByteString) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a RawString> for &'a LiteralExpr {
    fn from(n: &'a RawString) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a RawByteString> for &'a LiteralExpr {
    fn from(n: &'a RawByteString) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a Char> for &'a LiteralExpr {
    fn from(n: &'a Char) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a Byte> for &'a LiteralExpr {
    fn from(n: &'a Byte) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a IntNumber> for &'a LiteralExpr {
    fn from(n: &'a IntNumber) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a FloatNumber> for &'a LiteralExpr {
    fn from(n: &'a FloatNumber) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TrueKw> for &'a LiteralExpr {
    fn from(n: &'a TrueKw) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a FalseKw> for &'a LiteralExpr {
    fn from(n: &'a FalseKw) -> &'a LiteralExpr {
        LiteralExpr::cast(&n.syntax).unwrap()
    }
}


impl AstNode for LiteralExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | STRING
            | BYTE_STRING
            | RAW_STRING
            | RAW_BYTE_STRING
            | CHAR
            | BYTE
            | INT_NUMBER
            | FLOAT_NUMBER
            | TRUE_KW
            | FALSE_KW => Some(LiteralExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LiteralExpr {
    type Owned = TreeArc<LiteralExpr>;
    fn to_owned(&self) -> TreeArc<LiteralExpr> { TreeArc::cast(self.syntax.to_owned()) }
}

impl LiteralExpr {
    pub fn kind(&self) -> LiteralExprKind {
        match self.syntax.kind() {
            STRING => LiteralExprKind::String(String::cast(&self.syntax).unwrap()),
            BYTE_STRING => LiteralExprKind::ByteString(ByteString::cast(&self.syntax).unwrap()),
            RAW_STRING => LiteralExprKind::RawString(RawString::cast(&self.syntax).unwrap()),
            RAW_BYTE_STRING => LiteralExprKind::RawByteString(RawByteString::cast(&self.syntax).unwrap()),
            CHAR => LiteralExprKind::Char(Char::cast(&self.syntax).unwrap()),
            BYTE => LiteralExprKind::Byte(Byte::cast(&self.syntax).unwrap()),
            INT_NUMBER => LiteralExprKind::IntNumber(IntNumber::cast(&self.syntax).unwrap()),
            FLOAT_NUMBER => LiteralExprKind::FloatNumber(FloatNumber::cast(&self.syntax).unwrap()),
            TRUE_KW => LiteralExprKind::TrueKw(TrueKw::cast(&self.syntax).unwrap()),
            FALSE_KW => LiteralExprKind::FalseKw(FalseKw::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl LiteralExpr {}

// LiteralPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LiteralPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LiteralPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LITERAL_PAT => Some(LiteralPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LiteralPat {
    type Owned = TreeArc<LiteralPat>;
    fn to_owned(&self) -> TreeArc<LiteralPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl LiteralPat {
    pub fn literal(&self) -> Option<&Literal> {
        super::child_opt(self)
    }
}

// LoopExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct LoopExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for LoopExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for LoopExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            LOOP_EXPR => Some(LoopExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for LoopExpr {
    type Owned = TreeArc<LoopExpr>;
    fn to_owned(&self) -> TreeArc<LoopExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::LoopBodyOwner for LoopExpr {}
impl LoopExpr {}

// MacroCall
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MacroCall {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MacroCall {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MacroCall {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MACRO_CALL => Some(MacroCall::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MacroCall {
    type Owned = TreeArc<MacroCall>;
    fn to_owned(&self) -> TreeArc<MacroCall> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for MacroCall {}
impl ast::AttrsOwner for MacroCall {}
impl MacroCall {
    pub fn token_tree(&self) -> Option<&TokenTree> {
        super::child_opt(self)
    }

    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// MatchArm
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MatchArm {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MatchArm {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MATCH_ARM => Some(MatchArm::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MatchArm {
    type Owned = TreeArc<MatchArm>;
    fn to_owned(&self) -> TreeArc<MatchArm> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AttrsOwner for MatchArm {}
impl MatchArm {
    pub fn pats(&self) -> impl Iterator<Item = &Pat> {
        super::children(self)
    }

    pub fn guard(&self) -> Option<&MatchGuard> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// MatchArmList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MatchArmList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MatchArmList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MATCH_ARM_LIST => Some(MatchArmList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MatchArmList {
    type Owned = TreeArc<MatchArmList>;
    fn to_owned(&self) -> TreeArc<MatchArmList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AttrsOwner for MatchArmList {}
impl MatchArmList {
    pub fn arms(&self) -> impl Iterator<Item = &MatchArm> {
        super::children(self)
    }
}

// MatchExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MatchExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MatchExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MATCH_EXPR => Some(MatchExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MatchExpr {
    type Owned = TreeArc<MatchExpr>;
    fn to_owned(&self) -> TreeArc<MatchExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl MatchExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }

    pub fn match_arm_list(&self) -> Option<&MatchArmList> {
        super::child_opt(self)
    }
}

// MatchGuard
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MatchGuard {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MatchGuard {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MatchGuard {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MATCH_GUARD => Some(MatchGuard::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MatchGuard {
    type Owned = TreeArc<MatchGuard>;
    fn to_owned(&self) -> TreeArc<MatchGuard> { TreeArc::cast(self.syntax.to_owned()) }
}


impl MatchGuard {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// MethodCallExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MethodCallExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for MethodCallExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for MethodCallExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            METHOD_CALL_EXPR => Some(MethodCallExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for MethodCallExpr {
    type Owned = TreeArc<MethodCallExpr>;
    fn to_owned(&self) -> TreeArc<MethodCallExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::ArgListOwner for MethodCallExpr {}
impl MethodCallExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }

    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }

    pub fn type_arg_list(&self) -> Option<&TypeArgList> {
        super::child_opt(self)
    }
}

// Module
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Module {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Module {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Module {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            MODULE => Some(Module::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Module {
    type Owned = TreeArc<Module>;
    fn to_owned(&self) -> TreeArc<Module> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for Module {}
impl ast::NameOwner for Module {}
impl ast::AttrsOwner for Module {}
impl ast::DocCommentsOwner for Module {}
impl Module {
    pub fn item_list(&self) -> Option<&ItemList> {
        super::child_opt(self)
    }
}

// ModuleItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ModuleItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ModuleItem {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModuleItemKind<'a> {
    StructDef(&'a StructDef),
    EnumDef(&'a EnumDef),
    FnDef(&'a FnDef),
    TraitDef(&'a TraitDef),
    TypeAliasDef(&'a TypeAliasDef),
    ImplBlock(&'a ImplBlock),
    UseItem(&'a UseItem),
    ExternCrateItem(&'a ExternCrateItem),
    ConstDef(&'a ConstDef),
    StaticDef(&'a StaticDef),
    Module(&'a Module),
}
impl<'a> From<&'a StructDef> for &'a ModuleItem {
    fn from(n: &'a StructDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a EnumDef> for &'a ModuleItem {
    fn from(n: &'a EnumDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a FnDef> for &'a ModuleItem {
    fn from(n: &'a FnDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TraitDef> for &'a ModuleItem {
    fn from(n: &'a TraitDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TypeAliasDef> for &'a ModuleItem {
    fn from(n: &'a TypeAliasDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ImplBlock> for &'a ModuleItem {
    fn from(n: &'a ImplBlock) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a UseItem> for &'a ModuleItem {
    fn from(n: &'a UseItem) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ExternCrateItem> for &'a ModuleItem {
    fn from(n: &'a ExternCrateItem) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ConstDef> for &'a ModuleItem {
    fn from(n: &'a ConstDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a StaticDef> for &'a ModuleItem {
    fn from(n: &'a StaticDef) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a Module> for &'a ModuleItem {
    fn from(n: &'a Module) -> &'a ModuleItem {
        ModuleItem::cast(&n.syntax).unwrap()
    }
}


impl AstNode for ModuleItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | STRUCT_DEF
            | ENUM_DEF
            | FN_DEF
            | TRAIT_DEF
            | TYPE_ALIAS_DEF
            | IMPL_BLOCK
            | USE_ITEM
            | EXTERN_CRATE_ITEM
            | CONST_DEF
            | STATIC_DEF
            | MODULE => Some(ModuleItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ModuleItem {
    type Owned = TreeArc<ModuleItem>;
    fn to_owned(&self) -> TreeArc<ModuleItem> { TreeArc::cast(self.syntax.to_owned()) }
}

impl ModuleItem {
    pub fn kind(&self) -> ModuleItemKind {
        match self.syntax.kind() {
            STRUCT_DEF => ModuleItemKind::StructDef(StructDef::cast(&self.syntax).unwrap()),
            ENUM_DEF => ModuleItemKind::EnumDef(EnumDef::cast(&self.syntax).unwrap()),
            FN_DEF => ModuleItemKind::FnDef(FnDef::cast(&self.syntax).unwrap()),
            TRAIT_DEF => ModuleItemKind::TraitDef(TraitDef::cast(&self.syntax).unwrap()),
            TYPE_ALIAS_DEF => ModuleItemKind::TypeAliasDef(TypeAliasDef::cast(&self.syntax).unwrap()),
            IMPL_BLOCK => ModuleItemKind::ImplBlock(ImplBlock::cast(&self.syntax).unwrap()),
            USE_ITEM => ModuleItemKind::UseItem(UseItem::cast(&self.syntax).unwrap()),
            EXTERN_CRATE_ITEM => ModuleItemKind::ExternCrateItem(ExternCrateItem::cast(&self.syntax).unwrap()),
            CONST_DEF => ModuleItemKind::ConstDef(ConstDef::cast(&self.syntax).unwrap()),
            STATIC_DEF => ModuleItemKind::StaticDef(StaticDef::cast(&self.syntax).unwrap()),
            MODULE => ModuleItemKind::Module(Module::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ModuleItem {}

// Name
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Name {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Name {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME => Some(Name::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Name {
    type Owned = TreeArc<Name>;
    fn to_owned(&self) -> TreeArc<Name> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Name {}

// NameRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NameRef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NameRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAME_REF => Some(NameRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NameRef {
    type Owned = TreeArc<NameRef>;
    fn to_owned(&self) -> TreeArc<NameRef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NameRef {}

// NamedField
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NamedField {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NamedField {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAMED_FIELD => Some(NamedField::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NamedField {
    type Owned = TreeArc<NamedField>;
    fn to_owned(&self) -> TreeArc<NamedField> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NamedField {
    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// NamedFieldDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NamedFieldDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NamedFieldDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NamedFieldDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAMED_FIELD_DEF => Some(NamedFieldDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NamedFieldDef {
    type Owned = TreeArc<NamedFieldDef>;
    fn to_owned(&self) -> TreeArc<NamedFieldDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for NamedFieldDef {}
impl ast::NameOwner for NamedFieldDef {}
impl ast::AttrsOwner for NamedFieldDef {}
impl ast::DocCommentsOwner for NamedFieldDef {}
impl ast::TypeAscriptionOwner for NamedFieldDef {}
impl NamedFieldDef {}

// NamedFieldDefList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NamedFieldDefList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NamedFieldDefList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NamedFieldDefList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAMED_FIELD_DEF_LIST => Some(NamedFieldDefList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NamedFieldDefList {
    type Owned = TreeArc<NamedFieldDefList>;
    fn to_owned(&self) -> TreeArc<NamedFieldDefList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NamedFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = &NamedFieldDef> {
        super::children(self)
    }
}

// NamedFieldList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NamedFieldList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NamedFieldList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NAMED_FIELD_LIST => Some(NamedFieldList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NamedFieldList {
    type Owned = TreeArc<NamedFieldList>;
    fn to_owned(&self) -> TreeArc<NamedFieldList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NamedFieldList {
    pub fn fields(&self) -> impl Iterator<Item = &NamedField> {
        super::children(self)
    }
}

// NeverType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NeverType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NeverType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for NeverType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            NEVER_TYPE => Some(NeverType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NeverType {
    type Owned = TreeArc<NeverType>;
    fn to_owned(&self) -> TreeArc<NeverType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl NeverType {}

// NominalDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct NominalDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for NominalDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NominalDefKind<'a> {
    StructDef(&'a StructDef),
    EnumDef(&'a EnumDef),
}
impl<'a> From<&'a StructDef> for &'a NominalDef {
    fn from(n: &'a StructDef) -> &'a NominalDef {
        NominalDef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a EnumDef> for &'a NominalDef {
    fn from(n: &'a EnumDef) -> &'a NominalDef {
        NominalDef::cast(&n.syntax).unwrap()
    }
}


impl AstNode for NominalDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | STRUCT_DEF
            | ENUM_DEF => Some(NominalDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for NominalDef {
    type Owned = TreeArc<NominalDef>;
    fn to_owned(&self) -> TreeArc<NominalDef> { TreeArc::cast(self.syntax.to_owned()) }
}

impl NominalDef {
    pub fn kind(&self) -> NominalDefKind {
        match self.syntax.kind() {
            STRUCT_DEF => NominalDefKind::StructDef(StructDef::cast(&self.syntax).unwrap()),
            ENUM_DEF => NominalDefKind::EnumDef(EnumDef::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ast::NameOwner for NominalDef {}
impl ast::TypeParamsOwner for NominalDef {}
impl ast::AttrsOwner for NominalDef {}
impl NominalDef {}

// Param
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Param {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Param {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM => Some(Param::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Param {
    type Owned = TreeArc<Param>;
    fn to_owned(&self) -> TreeArc<Param> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::TypeAscriptionOwner for Param {}
impl Param {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }
}

// ParamList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ParamList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ParamList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PARAM_LIST => Some(ParamList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParamList {
    type Owned = TreeArc<ParamList>;
    fn to_owned(&self) -> TreeArc<ParamList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = &Param> {
        super::children(self)
    }

    pub fn self_param(&self) -> Option<&SelfParam> {
        super::child_opt(self)
    }
}

// ParenExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ParenExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ParenExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PAREN_EXPR => Some(ParenExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParenExpr {
    type Owned = TreeArc<ParenExpr>;
    fn to_owned(&self) -> TreeArc<ParenExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// ParenType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ParenType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ParenType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PAREN_TYPE => Some(ParenType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ParenType {
    type Owned = TreeArc<ParenType>;
    fn to_owned(&self) -> TreeArc<ParenType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ParenType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// Pat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Pat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Pat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PatKind<'a> {
    RefPat(&'a RefPat),
    BindPat(&'a BindPat),
    PlaceholderPat(&'a PlaceholderPat),
    PathPat(&'a PathPat),
    StructPat(&'a StructPat),
    TupleStructPat(&'a TupleStructPat),
    TuplePat(&'a TuplePat),
    SlicePat(&'a SlicePat),
    RangePat(&'a RangePat),
    LiteralPat(&'a LiteralPat),
}
impl<'a> From<&'a RefPat> for &'a Pat {
    fn from(n: &'a RefPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a BindPat> for &'a Pat {
    fn from(n: &'a BindPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PlaceholderPat> for &'a Pat {
    fn from(n: &'a PlaceholderPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PathPat> for &'a Pat {
    fn from(n: &'a PathPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a StructPat> for &'a Pat {
    fn from(n: &'a StructPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TupleStructPat> for &'a Pat {
    fn from(n: &'a TupleStructPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TuplePat> for &'a Pat {
    fn from(n: &'a TuplePat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a SlicePat> for &'a Pat {
    fn from(n: &'a SlicePat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a RangePat> for &'a Pat {
    fn from(n: &'a RangePat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a LiteralPat> for &'a Pat {
    fn from(n: &'a LiteralPat) -> &'a Pat {
        Pat::cast(&n.syntax).unwrap()
    }
}


impl AstNode for Pat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | REF_PAT
            | BIND_PAT
            | PLACEHOLDER_PAT
            | PATH_PAT
            | STRUCT_PAT
            | TUPLE_STRUCT_PAT
            | TUPLE_PAT
            | SLICE_PAT
            | RANGE_PAT
            | LITERAL_PAT => Some(Pat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Pat {
    type Owned = TreeArc<Pat>;
    fn to_owned(&self) -> TreeArc<Pat> { TreeArc::cast(self.syntax.to_owned()) }
}

impl Pat {
    pub fn kind(&self) -> PatKind {
        match self.syntax.kind() {
            REF_PAT => PatKind::RefPat(RefPat::cast(&self.syntax).unwrap()),
            BIND_PAT => PatKind::BindPat(BindPat::cast(&self.syntax).unwrap()),
            PLACEHOLDER_PAT => PatKind::PlaceholderPat(PlaceholderPat::cast(&self.syntax).unwrap()),
            PATH_PAT => PatKind::PathPat(PathPat::cast(&self.syntax).unwrap()),
            STRUCT_PAT => PatKind::StructPat(StructPat::cast(&self.syntax).unwrap()),
            TUPLE_STRUCT_PAT => PatKind::TupleStructPat(TupleStructPat::cast(&self.syntax).unwrap()),
            TUPLE_PAT => PatKind::TuplePat(TuplePat::cast(&self.syntax).unwrap()),
            SLICE_PAT => PatKind::SlicePat(SlicePat::cast(&self.syntax).unwrap()),
            RANGE_PAT => PatKind::RangePat(RangePat::cast(&self.syntax).unwrap()),
            LITERAL_PAT => PatKind::LiteralPat(LiteralPat::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Pat {}

// Path
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Path {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Path {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PATH => Some(Path::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Path {
    type Owned = TreeArc<Path>;
    fn to_owned(&self) -> TreeArc<Path> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Path {
    pub fn segment(&self) -> Option<&PathSegment> {
        super::child_opt(self)
    }

    pub fn qualifier(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// PathExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PathExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PathExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PATH_EXPR => Some(PathExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PathExpr {
    type Owned = TreeArc<PathExpr>;
    fn to_owned(&self) -> TreeArc<PathExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PathExpr {
    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// PathPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PathPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PathPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PathPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PATH_PAT => Some(PathPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PathPat {
    type Owned = TreeArc<PathPat>;
    fn to_owned(&self) -> TreeArc<PathPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PathPat {
    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// PathSegment
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PathSegment {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PathSegment {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PATH_SEGMENT => Some(PathSegment::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PathSegment {
    type Owned = TreeArc<PathSegment>;
    fn to_owned(&self) -> TreeArc<PathSegment> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PathSegment {
    pub fn name_ref(&self) -> Option<&NameRef> {
        super::child_opt(self)
    }

    pub fn type_arg_list(&self) -> Option<&TypeArgList> {
        super::child_opt(self)
    }
}

// PathType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PathType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PathType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PATH_TYPE => Some(PathType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PathType {
    type Owned = TreeArc<PathType>;
    fn to_owned(&self) -> TreeArc<PathType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PathType {
    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// PlaceholderPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PlaceholderPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PlaceholderPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PlaceholderPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PLACEHOLDER_PAT => Some(PlaceholderPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PlaceholderPat {
    type Owned = TreeArc<PlaceholderPat>;
    fn to_owned(&self) -> TreeArc<PlaceholderPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PlaceholderPat {}

// PlaceholderType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PlaceholderType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PlaceholderType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PlaceholderType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PLACEHOLDER_TYPE => Some(PlaceholderType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PlaceholderType {
    type Owned = TreeArc<PlaceholderType>;
    fn to_owned(&self) -> TreeArc<PlaceholderType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PlaceholderType {}

// PointerType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PointerType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PointerType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PointerType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            POINTER_TYPE => Some(PointerType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PointerType {
    type Owned = TreeArc<PointerType>;
    fn to_owned(&self) -> TreeArc<PointerType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PointerType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// PosFieldDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PosFieldDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PosFieldDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PosFieldDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            POS_FIELD_DEF => Some(PosFieldDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PosFieldDef {
    type Owned = TreeArc<PosFieldDef>;
    fn to_owned(&self) -> TreeArc<PosFieldDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for PosFieldDef {}
impl ast::AttrsOwner for PosFieldDef {}
impl PosFieldDef {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// PosFieldDefList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PosFieldDefList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PosFieldDefList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PosFieldDefList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            POS_FIELD_DEF_LIST => Some(PosFieldDefList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PosFieldDefList {
    type Owned = TreeArc<PosFieldDefList>;
    fn to_owned(&self) -> TreeArc<PosFieldDefList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PosFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = &PosFieldDef> {
        super::children(self)
    }
}

// PrefixExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for PrefixExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for PrefixExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            PREFIX_EXPR => Some(PrefixExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for PrefixExpr {
    type Owned = TreeArc<PrefixExpr>;
    fn to_owned(&self) -> TreeArc<PrefixExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// RangeExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RangeExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RangeExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RANGE_EXPR => Some(RangeExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RangeExpr {
    type Owned = TreeArc<RangeExpr>;
    fn to_owned(&self) -> TreeArc<RangeExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl RangeExpr {}

// RangePat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RangePat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RangePat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RangePat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RANGE_PAT => Some(RangePat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RangePat {
    type Owned = TreeArc<RangePat>;
    fn to_owned(&self) -> TreeArc<RangePat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl RangePat {}

// RawByteString
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RawByteString {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RawByteString {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RawByteString {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RAW_BYTE_STRING => Some(RawByteString::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RawByteString {
    type Owned = TreeArc<RawByteString>;
    fn to_owned(&self) -> TreeArc<RawByteString> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for RawByteString {}
impl RawByteString {}

// RawString
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RawString {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RawString {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RawString {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RAW_STRING => Some(RawString::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RawString {
    type Owned = TreeArc<RawString>;
    fn to_owned(&self) -> TreeArc<RawString> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for RawString {}
impl RawString {}

// RefExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RefExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RefExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RefExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            REF_EXPR => Some(RefExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RefExpr {
    type Owned = TreeArc<RefExpr>;
    fn to_owned(&self) -> TreeArc<RefExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl RefExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// RefPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RefPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RefPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RefPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            REF_PAT => Some(RefPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RefPat {
    type Owned = TreeArc<RefPat>;
    fn to_owned(&self) -> TreeArc<RefPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl RefPat {
    pub fn pat(&self) -> Option<&Pat> {
        super::child_opt(self)
    }
}

// ReferenceType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ReferenceType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ReferenceType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ReferenceType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            REFERENCE_TYPE => Some(ReferenceType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ReferenceType {
    type Owned = TreeArc<ReferenceType>;
    fn to_owned(&self) -> TreeArc<ReferenceType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ReferenceType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// RetType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for RetType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for RetType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RET_TYPE => Some(RetType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for RetType {
    type Owned = TreeArc<RetType>;
    fn to_owned(&self) -> TreeArc<RetType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl RetType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// ReturnExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for ReturnExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for ReturnExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            RETURN_EXPR => Some(ReturnExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for ReturnExpr {
    type Owned = TreeArc<ReturnExpr>;
    fn to_owned(&self) -> TreeArc<ReturnExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ReturnExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// SelfKw
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SelfKw {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for SelfKw {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for SelfKw {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SELF_KW => Some(SelfKw::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SelfKw {
    type Owned = TreeArc<SelfKw>;
    fn to_owned(&self) -> TreeArc<SelfKw> { TreeArc::cast(self.syntax.to_owned()) }
}


impl SelfKw {}

// SelfParam
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SelfParam {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for SelfParam {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for SelfParam {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SELF_PARAM => Some(SelfParam::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SelfParam {
    type Owned = TreeArc<SelfParam>;
    fn to_owned(&self) -> TreeArc<SelfParam> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::TypeAscriptionOwner for SelfParam {}
impl SelfParam {
    pub fn self_kw(&self) -> Option<&SelfKw> {
        super::child_opt(self)
    }
}

// SlicePat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SlicePat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for SlicePat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for SlicePat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SLICE_PAT => Some(SlicePat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SlicePat {
    type Owned = TreeArc<SlicePat>;
    fn to_owned(&self) -> TreeArc<SlicePat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl SlicePat {}

// SliceType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SliceType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for SliceType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for SliceType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SLICE_TYPE => Some(SliceType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SliceType {
    type Owned = TreeArc<SliceType>;
    fn to_owned(&self) -> TreeArc<SliceType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl SliceType {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// SourceFile
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for SourceFile {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for SourceFile {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            SOURCE_FILE => Some(SourceFile::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for SourceFile {
    type Owned = TreeArc<SourceFile>;
    fn to_owned(&self) -> TreeArc<SourceFile> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::ModuleItemOwner for SourceFile {}
impl ast::FnDefOwner for SourceFile {}
impl SourceFile {
    pub fn modules(&self) -> impl Iterator<Item = &Module> {
        super::children(self)
    }
}

// StaticDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct StaticDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for StaticDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for StaticDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            STATIC_DEF => Some(StaticDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for StaticDef {
    type Owned = TreeArc<StaticDef>;
    fn to_owned(&self) -> TreeArc<StaticDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for StaticDef {}
impl ast::NameOwner for StaticDef {}
impl ast::TypeParamsOwner for StaticDef {}
impl ast::AttrsOwner for StaticDef {}
impl ast::DocCommentsOwner for StaticDef {}
impl ast::TypeAscriptionOwner for StaticDef {}
impl StaticDef {}

// Stmt
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Stmt {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Stmt {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StmtKind<'a> {
    ExprStmt(&'a ExprStmt),
    LetStmt(&'a LetStmt),
}
impl<'a> From<&'a ExprStmt> for &'a Stmt {
    fn from(n: &'a ExprStmt) -> &'a Stmt {
        Stmt::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a LetStmt> for &'a Stmt {
    fn from(n: &'a LetStmt) -> &'a Stmt {
        Stmt::cast(&n.syntax).unwrap()
    }
}


impl AstNode for Stmt {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | EXPR_STMT
            | LET_STMT => Some(Stmt::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Stmt {
    type Owned = TreeArc<Stmt>;
    fn to_owned(&self) -> TreeArc<Stmt> { TreeArc::cast(self.syntax.to_owned()) }
}

impl Stmt {
    pub fn kind(&self) -> StmtKind {
        match self.syntax.kind() {
            EXPR_STMT => StmtKind::ExprStmt(ExprStmt::cast(&self.syntax).unwrap()),
            LET_STMT => StmtKind::LetStmt(LetStmt::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Stmt {}

// String
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct String {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for String {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for String {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            STRING => Some(String::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for String {
    type Owned = TreeArc<String>;
    fn to_owned(&self) -> TreeArc<String> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for String {}
impl String {}

// StructDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct StructDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for StructDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for StructDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(StructDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for StructDef {
    type Owned = TreeArc<StructDef>;
    fn to_owned(&self) -> TreeArc<StructDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for StructDef {}
impl ast::NameOwner for StructDef {}
impl ast::TypeParamsOwner for StructDef {}
impl ast::AttrsOwner for StructDef {}
impl ast::DocCommentsOwner for StructDef {}
impl StructDef {}

// StructLit
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct StructLit {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for StructLit {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for StructLit {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            STRUCT_LIT => Some(StructLit::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for StructLit {
    type Owned = TreeArc<StructLit>;
    fn to_owned(&self) -> TreeArc<StructLit> { TreeArc::cast(self.syntax.to_owned()) }
}


impl StructLit {
    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }

    pub fn named_field_list(&self) -> Option<&NamedFieldList> {
        super::child_opt(self)
    }

    pub fn spread(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// StructPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct StructPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for StructPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for StructPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            STRUCT_PAT => Some(StructPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for StructPat {
    type Owned = TreeArc<StructPat>;
    fn to_owned(&self) -> TreeArc<StructPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl StructPat {
    pub fn field_pat_list(&self) -> Option<&FieldPatList> {
        super::child_opt(self)
    }

    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// TokenTree
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TokenTree {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TokenTree {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TokenTree {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TOKEN_TREE => Some(TokenTree::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TokenTree {
    type Owned = TreeArc<TokenTree>;
    fn to_owned(&self) -> TreeArc<TokenTree> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TokenTree {}

// TraitDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TraitDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TraitDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TraitDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TRAIT_DEF => Some(TraitDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TraitDef {
    type Owned = TreeArc<TraitDef>;
    fn to_owned(&self) -> TreeArc<TraitDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for TraitDef {}
impl ast::NameOwner for TraitDef {}
impl ast::AttrsOwner for TraitDef {}
impl ast::DocCommentsOwner for TraitDef {}
impl ast::TypeParamsOwner for TraitDef {}
impl TraitDef {}

// TrueKw
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TrueKw {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TrueKw {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TrueKw {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TRUE_KW => Some(TrueKw::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TrueKw {
    type Owned = TreeArc<TrueKw>;
    fn to_owned(&self) -> TreeArc<TrueKw> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for TrueKw {}
impl TrueKw {}

// TryExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TryExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TryExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TRY_EXPR => Some(TryExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TryExpr {
    type Owned = TreeArc<TryExpr>;
    fn to_owned(&self) -> TreeArc<TryExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TryExpr {
    pub fn expr(&self) -> Option<&Expr> {
        super::child_opt(self)
    }
}

// TupleExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TupleExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TupleExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TUPLE_EXPR => Some(TupleExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TupleExpr {
    type Owned = TreeArc<TupleExpr>;
    fn to_owned(&self) -> TreeArc<TupleExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TupleExpr {
    pub fn exprs(&self) -> impl Iterator<Item = &Expr> {
        super::children(self)
    }
}

// TuplePat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TuplePat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TuplePat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TUPLE_PAT => Some(TuplePat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TuplePat {
    type Owned = TreeArc<TuplePat>;
    fn to_owned(&self) -> TreeArc<TuplePat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TuplePat {
    pub fn args(&self) -> impl Iterator<Item = &Pat> {
        super::children(self)
    }
}

// TupleStructPat
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TupleStructPat {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TupleStructPat {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TupleStructPat {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TUPLE_STRUCT_PAT => Some(TupleStructPat::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TupleStructPat {
    type Owned = TreeArc<TupleStructPat>;
    fn to_owned(&self) -> TreeArc<TupleStructPat> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TupleStructPat {
    pub fn args(&self) -> impl Iterator<Item = &Pat> {
        super::children(self)
    }

    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }
}

// TupleType
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TupleType {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TupleType {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TupleType {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TUPLE_TYPE => Some(TupleType::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TupleType {
    type Owned = TreeArc<TupleType>;
    fn to_owned(&self) -> TreeArc<TupleType> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TupleType {
    pub fn fields(&self) -> impl Iterator<Item = &TypeRef> {
        super::children(self)
    }
}

// TypeAliasDef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeAliasDef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeAliasDef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TypeAliasDef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TYPE_ALIAS_DEF => Some(TypeAliasDef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeAliasDef {
    type Owned = TreeArc<TypeAliasDef>;
    fn to_owned(&self) -> TreeArc<TypeAliasDef> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::VisibilityOwner for TypeAliasDef {}
impl ast::NameOwner for TypeAliasDef {}
impl ast::TypeParamsOwner for TypeAliasDef {}
impl ast::AttrsOwner for TypeAliasDef {}
impl ast::DocCommentsOwner for TypeAliasDef {}
impl TypeAliasDef {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// TypeArg
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeArg {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TypeArg {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TYPE_ARG => Some(TypeArg::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeArg {
    type Owned = TreeArc<TypeArg>;
    fn to_owned(&self) -> TreeArc<TypeArg> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TypeArg {
    pub fn type_ref(&self) -> Option<&TypeRef> {
        super::child_opt(self)
    }
}

// TypeArgList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeArgList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TypeArgList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TYPE_ARG_LIST => Some(TypeArgList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeArgList {
    type Owned = TreeArc<TypeArgList>;
    fn to_owned(&self) -> TreeArc<TypeArgList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TypeArgList {
    pub fn type_args(&self) -> impl Iterator<Item = &TypeArg> {
        super::children(self)
    }

    pub fn lifetime_args(&self) -> impl Iterator<Item = &LifetimeArg> {
        super::children(self)
    }

    pub fn assoc_type_args(&self) -> impl Iterator<Item = &AssocTypeArg> {
        super::children(self)
    }
}

// TypeParam
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeParam {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TypeParam {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TYPE_PARAM => Some(TypeParam::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeParam {
    type Owned = TreeArc<TypeParam>;
    fn to_owned(&self) -> TreeArc<TypeParam> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::NameOwner for TypeParam {}
impl ast::AttrsOwner for TypeParam {}
impl TypeParam {}

// TypeParamList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeParamList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for TypeParamList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            TYPE_PARAM_LIST => Some(TypeParamList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeParamList {
    type Owned = TreeArc<TypeParamList>;
    fn to_owned(&self) -> TreeArc<TypeParamList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl TypeParamList {
    pub fn type_params(&self) -> impl Iterator<Item = &TypeParam> {
        super::children(self)
    }

    pub fn lifetime_params(&self) -> impl Iterator<Item = &LifetimeParam> {
        super::children(self)
    }
}

// TypeRef
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for TypeRef {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TypeRefKind<'a> {
    ParenType(&'a ParenType),
    TupleType(&'a TupleType),
    NeverType(&'a NeverType),
    PathType(&'a PathType),
    PointerType(&'a PointerType),
    ArrayType(&'a ArrayType),
    SliceType(&'a SliceType),
    ReferenceType(&'a ReferenceType),
    PlaceholderType(&'a PlaceholderType),
    FnPointerType(&'a FnPointerType),
    ForType(&'a ForType),
    ImplTraitType(&'a ImplTraitType),
    DynTraitType(&'a DynTraitType),
}
impl<'a> From<&'a ParenType> for &'a TypeRef {
    fn from(n: &'a ParenType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a TupleType> for &'a TypeRef {
    fn from(n: &'a TupleType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a NeverType> for &'a TypeRef {
    fn from(n: &'a NeverType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PathType> for &'a TypeRef {
    fn from(n: &'a PathType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PointerType> for &'a TypeRef {
    fn from(n: &'a PointerType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ArrayType> for &'a TypeRef {
    fn from(n: &'a ArrayType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a SliceType> for &'a TypeRef {
    fn from(n: &'a SliceType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ReferenceType> for &'a TypeRef {
    fn from(n: &'a ReferenceType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a PlaceholderType> for &'a TypeRef {
    fn from(n: &'a PlaceholderType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a FnPointerType> for &'a TypeRef {
    fn from(n: &'a FnPointerType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ForType> for &'a TypeRef {
    fn from(n: &'a ForType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a ImplTraitType> for &'a TypeRef {
    fn from(n: &'a ImplTraitType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}
impl<'a> From<&'a DynTraitType> for &'a TypeRef {
    fn from(n: &'a DynTraitType) -> &'a TypeRef {
        TypeRef::cast(&n.syntax).unwrap()
    }
}


impl AstNode for TypeRef {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            | PAREN_TYPE
            | TUPLE_TYPE
            | NEVER_TYPE
            | PATH_TYPE
            | POINTER_TYPE
            | ARRAY_TYPE
            | SLICE_TYPE
            | REFERENCE_TYPE
            | PLACEHOLDER_TYPE
            | FN_POINTER_TYPE
            | FOR_TYPE
            | IMPL_TRAIT_TYPE
            | DYN_TRAIT_TYPE => Some(TypeRef::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for TypeRef {
    type Owned = TreeArc<TypeRef>;
    fn to_owned(&self) -> TreeArc<TypeRef> { TreeArc::cast(self.syntax.to_owned()) }
}

impl TypeRef {
    pub fn kind(&self) -> TypeRefKind {
        match self.syntax.kind() {
            PAREN_TYPE => TypeRefKind::ParenType(ParenType::cast(&self.syntax).unwrap()),
            TUPLE_TYPE => TypeRefKind::TupleType(TupleType::cast(&self.syntax).unwrap()),
            NEVER_TYPE => TypeRefKind::NeverType(NeverType::cast(&self.syntax).unwrap()),
            PATH_TYPE => TypeRefKind::PathType(PathType::cast(&self.syntax).unwrap()),
            POINTER_TYPE => TypeRefKind::PointerType(PointerType::cast(&self.syntax).unwrap()),
            ARRAY_TYPE => TypeRefKind::ArrayType(ArrayType::cast(&self.syntax).unwrap()),
            SLICE_TYPE => TypeRefKind::SliceType(SliceType::cast(&self.syntax).unwrap()),
            REFERENCE_TYPE => TypeRefKind::ReferenceType(ReferenceType::cast(&self.syntax).unwrap()),
            PLACEHOLDER_TYPE => TypeRefKind::PlaceholderType(PlaceholderType::cast(&self.syntax).unwrap()),
            FN_POINTER_TYPE => TypeRefKind::FnPointerType(FnPointerType::cast(&self.syntax).unwrap()),
            FOR_TYPE => TypeRefKind::ForType(ForType::cast(&self.syntax).unwrap()),
            IMPL_TRAIT_TYPE => TypeRefKind::ImplTraitType(ImplTraitType::cast(&self.syntax).unwrap()),
            DYN_TRAIT_TYPE => TypeRefKind::DynTraitType(DynTraitType::cast(&self.syntax).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl TypeRef {}

// UseItem
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct UseItem {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for UseItem {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for UseItem {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            USE_ITEM => Some(UseItem::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for UseItem {
    type Owned = TreeArc<UseItem>;
    fn to_owned(&self) -> TreeArc<UseItem> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AttrsOwner for UseItem {}
impl UseItem {
    pub fn use_tree(&self) -> Option<&UseTree> {
        super::child_opt(self)
    }
}

// UseTree
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct UseTree {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for UseTree {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for UseTree {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            USE_TREE => Some(UseTree::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for UseTree {
    type Owned = TreeArc<UseTree>;
    fn to_owned(&self) -> TreeArc<UseTree> { TreeArc::cast(self.syntax.to_owned()) }
}


impl UseTree {
    pub fn path(&self) -> Option<&Path> {
        super::child_opt(self)
    }

    pub fn use_tree_list(&self) -> Option<&UseTreeList> {
        super::child_opt(self)
    }

    pub fn alias(&self) -> Option<&Alias> {
        super::child_opt(self)
    }
}

// UseTreeList
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct UseTreeList {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for UseTreeList {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for UseTreeList {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            USE_TREE_LIST => Some(UseTreeList::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for UseTreeList {
    type Owned = TreeArc<UseTreeList>;
    fn to_owned(&self) -> TreeArc<UseTreeList> { TreeArc::cast(self.syntax.to_owned()) }
}


impl UseTreeList {
    pub fn use_trees(&self) -> impl Iterator<Item = &UseTree> {
        super::children(self)
    }
}

// Visibility
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Visibility {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Visibility {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            VISIBILITY => Some(Visibility::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Visibility {
    type Owned = TreeArc<Visibility>;
    fn to_owned(&self) -> TreeArc<Visibility> { TreeArc::cast(self.syntax.to_owned()) }
}


impl Visibility {}

// WhereClause
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct WhereClause {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for WhereClause {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for WhereClause {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            WHERE_CLAUSE => Some(WhereClause::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for WhereClause {
    type Owned = TreeArc<WhereClause>;
    fn to_owned(&self) -> TreeArc<WhereClause> { TreeArc::cast(self.syntax.to_owned()) }
}


impl WhereClause {}

// WhileExpr
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for WhileExpr {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for WhileExpr {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            WHILE_EXPR => Some(WhileExpr::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for WhileExpr {
    type Owned = TreeArc<WhileExpr>;
    fn to_owned(&self) -> TreeArc<WhileExpr> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::LoopBodyOwner for WhileExpr {}
impl WhileExpr {
    pub fn condition(&self) -> Option<&Condition> {
        super::child_opt(self)
    }
}

// Whitespace
#[derive(Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Whitespace {
    pub(crate) syntax: SyntaxNode,
}
unsafe impl TransparentNewType for Whitespace {
    type Repr = rowan::SyntaxNode<RaTypes>;
}

impl AstNode for Whitespace {
    fn cast(syntax: &SyntaxNode) -> Option<&Self> {
        match syntax.kind() {
            WHITESPACE => Some(Whitespace::from_repr(syntax.into_repr())),
            _ => None,
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}

impl ToOwned for Whitespace {
    type Owned = TreeArc<Whitespace>;
    fn to_owned(&self) -> TreeArc<Whitespace> { TreeArc::cast(self.syntax.to_owned()) }
}


impl ast::AstToken for Whitespace {}
impl Whitespace {}

